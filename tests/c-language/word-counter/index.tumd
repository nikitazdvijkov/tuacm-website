article
Title:		Making a Word Counter in C
Author:		Joseph Mellor
Tagline:	We're going to write our first serious program.
Code Style:	trac+dark
Import:		code-block terminal aside
Scripts:	highlight-internal-link

\{{style}}

.terminal pre {
	color: #AAAAAA;
}

.terminal .file {
	color: #295FCC;
	font-weight: bold;
}

.terminal .exe {
	color: #4CE64C;
	font-weight: bold;
}

#creating-a-file {
	border-radius: 8px;
	margin-bottom: 1em;
	padding: 5px;
}

#creating-a-file p {
	margin-bottom: 0;
}

\{{\style}}


<i>This is the sixteenth article in the </i>Making Sense of C<i> series.
In this article, we're going to write a basic word counter, our first goal in
programming in {C}.</i>

We had to set up a lot of features in {C} to get to this point, but we're
finally here.

Up to this point, we've

\{{ul}}

determined that we're going to give the compiler a file with a bunch of
statements ending in semicolons,

established that we can use comments with {//} for single line comments and {/*}
and {*/} for multiline comments,

reserved the symbols {+-*/%} for arithmetic,

set up variables {[type] [variable] = [expression]} which will allow us to store
values for later use,

come up with the integral types ({char}, {short}, {int}, and {long long}) and
the floating point types ({float} and {double}),

figured out a way to represent characters using the {char} type and invented the
{NULL} character, which indicates that we're ending a string,

and decided to use single quotes around a character to represent the ASCII value
for that {char}.

explained how the program uses memory addresses to identify variables,

came up with a way to access the memory address of a variable using the <b>
address of</b> operator ({&amp;}),

came up with a way to access the value stored at a memory address using the
<b>dereference</b> operator ({*}),

created <b>pointer</b> variables to allow us to store memory addresses using the
syntax {type * variable_name;},

came up with a way to tell the computer to get us a block of memory (a.k.a. an
<b>array</b> or <b>buffer</b>) using the syntax {type
array[num_elements];},

came up with a way to initialize an array with an <b>initializer list</b>,

came up with a way to initialize a {char} array using double quotes,
({"Hello!"}),

came up with a way to access elements of an array using the syntax
{variable_name[offset]},

introduced a way to compare two values using the <b>relational operators</b>
({{{lt}}}, {{{gt}}}, {{{lt}}}=, {{{gt}}}=, {==}, {!=}),

introduced ways to combine or invert Boolean statements using the <b>logical
operators</b> ({&amp;&amp;}, {||}, and {!}),

reserved the {if} and {else} keywords so that our program can act differently
if given different inputs (a.k.a. <b>conditional branches</b>),

added {while} and {do while} loops for <b>unindexed looping</b>,

added {for} loops for <b>indexed looping</b>,

introduced functions to help break our code into more maintainable chunks and to
prevent us from typing the same thing repeatedly,

designated the {main} function as the entry point for our program and a way to
take in user input,

introduced the symbol table, which helps the compiler recognize valid code,

set up function declarations, which allow us to add functions to the symbol
table,

introduced the preprocessor, which can generate code for us during compilation
without modifying the original source file,

added the {#include} macro and the concept of header files, which contain
function declarations and other stuff that we'll learn about later that allow us
to automate some of the process of addings things to the symbol table,

introduced {stdio.h}, which will allow us to do file I/O,

created the {FILE} type, which will allow us to interact with files,

created {fopen}, which will allow us to create a {file} object from a filename
and a mode,

reserved the keyword {const}, which tells the compiler we will not modify
something and allows us to use certain things like string literals,

created {fclose}, which will allow us to clean up a {file} object,

set up our compiler and IDE so that we can modify and compile {C} programs,

introduced {stdin} for user input, {stdout} for terminal output, and {stderr}
for error output,

created {fgets} to get a line from a file,

created {printf} to print to the terminal,

created {fprintf} to write to files,

and introduced <b>format strings</b> to make it easier for us to print things.

\{{\ul}}

These tools are sufficient for us to write our first program: the word counter.

# What is a Word?

Our definition of a word is any sequence of alphanumeric characters.
For example, "ji12fsadkl" would be a word but "f1.asd%as1" would be three words
because the period and the percent sign will break it apart.
You could define a word to mean something else (like anything separated by
spaces), but we're going to use this definition.

# Before We Begin

{{o-path}}="path/to/{{zs}}other/{{zs}}directory/{{zs}}c-tutorial"

This is a short step, but you'll want to create two new directories: one for
all the {C} tutorials in this series and one inside that one for the word
counter specifically.
First, if you're on Mac or Linux, open the terminal app.
If you're on Windows, open the Ubuntu app, which you should have installed in
the <a href="../compilers-and-ides/index.html#windows">Compilers and Ides for
C</a> article.
If you're on Mac or Linux, type in the command {cd ~}, which will put you in the
home folder (it's exactly like clicking on folders in the Windows or Mac
file explorer until you get to {Users/[your username]}).
If you're using the Windows Subsystem for Linux, type {cd /mnt/c/Users/[your
username]}, which will bring you to your home directory (i.e. the directory that
contains Desktop, Documents, Downloads, etc.).
Then, type {mkdir -p dev/c-tutorial}, which will then create a new directory in {~}.
<span style="color: #5500FF"><b>If you want to put your code in another
directory, you can use {mkdir -p {{o-path}}}</b></span>.
You can see a list of all the directories in your current folder by typing {ls}.
From there, type {cd c-tutorial} to move into the {c-tutorial} directory.
<span style="color: #5500FF"><b>If you put your code in another directory, you
can use {cd {{o-path}}} instead</b></span>.
Lastly, create a new directory called {word-counter} using {mkdir word-counter}
and move into it with {cd word-counter}.

The entire process should look like this:

\{{terminal}}

{{dir}}:="~/some/random/dir"
{{user}}:="user"
{{computer-name}}:="computer"
{{dir-color}}:="#295FCC"
{{u-and-c-color}}:="#4CE64C"

{{prompt}} cd ~
{{dir}}:="~"
{{prompt}} mkdir -p dev/c-tutorial
{{prompt}} ls
{{file}}:="<span class="file">{{rest-of-line}}</span>{{end-of-line}}"
{{exe}}:="<span class="exe">{{rest-of-line}}</span>{{end-of-line}}"
{{file}}c-tutorial
{{file}}Desktop
{{file}}Documents
{{file}}Downloads
{{file}}Music
{{file}}Pictures
{{file}}Public
{{file}}Videos
{{prompt}} cd dev/c-tutorial
{{dir}}:="~/dev/c-tutorial"
{{prompt}} mkdir word-counter
{{prompt}} cd word-counter
{{dir}}="{{dir}}/word-counter"
{{cursor}}:="<span style="font-size: 1.5em;">&#9646;</span>"
{{prompt}}

\{{\terminal}}

\{{raw-html}}
<div id="creating-a-file">
\{{\raw-html}}

Now that you're here, create a file called {word-counter.c}, which you can do
using your IDE, a text editor, or the command line.
If you're using an IDE or a text editor, go to <b>File</b> {{gt}} <b>Open</b>
{{gt}} <b>Folder</b>, navigate to the {word-counter} folder, and click on it.
Then, right click on the {word-counter} folder and click <b>New File</b>.
If you're using a command line text editor like {vim} or {nano}, then just type
{vim word-counter.c} or {nano word-counter.c} and the text editor should pop up
with a new file.

\{{raw-html}}
</div>
\{{\raw-html}}

\{{aside}}
#### Command Line Text Editors
<hr>

Although I personally use {vim} (I'm actually using it right now to write these
articles.) and would recommend it to an experienced programmer, I don't
recommend that any novices use it because it's made less for just putting text
on the screen like normal text editors (Google Docs, Microsoft Word, Notepad)
and more for coding.
It allows fast movement and operations throughout the code, but you have to put
in some effort.
The same reasoning also applies for {emacs} and {nano}.

\{{\aside}}

From here, we can start typing our code into our new file.

# The Top Level

We're going to start with our goal: counting the number of times a word shows up
in a file and printing that number to the terminal.
From there, we're going to go to the top level of our program, which will
correspond to our {main} function.

For us to count the number of times a word shows up in a file, we need to know
the word and the file to read from.
Then, we'll also need to store the count somewhere and print it out.

Our algorithm currently looks like

\{{ol}}

Get the user input.

Count the number of times the word shows up in a file.

Print the count of the word.

\{{\ol}}

## Getting User Input

For now, let's focus on getting the user input.
We can look through our list of tools we have in {C} (look above) and we find
that <a href="../main-function/index.html">the {main} function</a> will allow us
to get user input directly through its arguments, so we can just use it
directly.

\{{code-block c}}

int main(int argc, char ** argv) {
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
    // TODO: Count the number of times the word shows up in a file.
    // TODO: Print the count of the word.
    return 0;
}

\{{\code-block}}

Now you might notice a problem.
What happens if the user doesn't provide us with at least three arguments?
{argv[0]} always has to exist, but {argv[1]} and so on only exist if the user
provides other arguments on the command line.
We need to check that there are at least three arguments for the program to
continue running, so let's add that check.
Furthermore, if the user types the command in without the proper arguments, the
general response is to print out a usage message showing the user how to use it,
which we'll add too.
We want to print to {stderr}, so we'll need to use {fprintf} or {fputs} and
<a href="../header-files/index.html">we'll need to include {stdio.h}</a>.

\{{code-block c}}

#include {{lt}}stdio.h{{gt}}

int main(int argc, char ** argv) {
hl    if (3 {{gt}} argc) {
hl        fprintf(stderr, "./word_counter file_name word_to_find\n");
hl        return -1;
hl    }
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
    // TODO: Count the number of times the word shows up in a file.
    // TODO: Print the count of the word.
    return 0;
}

\{{\code-block}}

So now, we have the name of the file the user wants to run the program on in the
variable {file_name} and the word the user wants to find in {word}.

## Printing the Count

You might think it's a little weird that we skipped the part where we actually
count the word, but it's easy enough that we can do it in a few lines.
To print a number out to the screen, we can use {<a
href="../files-2/index.html">printf</a>} and be done with it.
Since we need to declare a variable before we can use it, we're going to declare
{unsigned int count = 0;} before we calculate the {count} of the word.

\{{code-block c}}

#include {{lt}}stdio.h{{gt}}

int main(int argc, char ** argv) {
    if (3 {{gt}} argc) {
        fprintf(stderr, "./word_counter file_name word_to_find\n");
        return -1;
    }
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
hl    unsigned int count = 0;
    // TODO: Count the number of times the word shows up in a file.
hl    printf("%d\n", count);
    return 0;
}

\{{\code-block}}

## Count How Often the Word Shows up in the File

Now we're going to get into some of the heavy lifting.
Here's how I'm thinking we break down this part of the algorithm:

\{{ol}}

Get the file into our {C} program in some way that we can interact with it.

Read the file line by line (since that's how you normally read files).

For each line, get the count of the word and add it to the total count.

\{{\ol}}

Let's work with this and see what happens.

### Getting the File into {C}

As we went over in the article on <a href="../files/index.html">files in
{C}</a>, we can get files from our computer into our program using {fopen},
which will return a {FILE *} object that we can use to interact with the file.
We'll want to <b>read</b> the file, so we're going to use {"r"} as the mode
(second argument to {fopen}).
Since we have to clean up after ourselves, we'll also need a corresponding
{fclose}.

\{{code-block c}}

#include {{lt}}stdio.h{{gt}}

int main(int argc, char ** argv) {
    if (3 {{gt}} argc) {
        fprintf(stderr, "./word_counter file_name word_to_find\n");
        return -1;
    }
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
    unsigned int count = 0;
hl    FILE * reader = fopen(file_name, "r");
    // TODO: Read the file line by line
    // TODO: For each line, get the count of the word and add it to
    //       the total count
hl    fclose(reader);
    printf("%d\n", count);
    return 0;
}

\{{\code-block}}

I decided to call the {FILE *} object {reader} since it's reading the file.
If I had done something stupid and called it something like {a}, then I could
end up accidentally confusing it for something else or not recognizing that I'm
using it incorrectly.

### Reading the File Line by Line

Now that we have a {FILE *}, we can read the file line by line.
We're going to need somewhere to store the line, and since the line is made up
of characters, we're going to use a {char} buffer.
We'll need to allocate a safe amount to get decently long lines, so let's
allocate room for {4096} (i.e. 2<sup>12</sup> or 4 KiB or about 4 kB)
characters.
If a user uses a line longer than {4096} characters, then {fgets} will
automatically break it into multiple lines every {4095} characters (remember
that the last character is the null terminator {'\0'}).
We also want to keep reading until we reach the end of the file, which {fgets}
will allow us to do.

\{{code-block c}}

#include {{lt}}stdio.h{{gt}}

int main(int argc, char ** argv) {
    if (3 {{gt}} argc) {
        fprintf(stderr, "./word_counter file_name word_to_find\n");
        return -1;
    }
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
    unsigned int count = 0;
    FILE * reader = fopen(file_name, "r");
hl    const int line_sz = 4096;           // There are better ways to do this
hl    char line[line_sz];                 // but we need features we haven't
hl                                        // gone over yet.
hl    while (fgets(line, line_sz, reader)) {
        // TODO: For each line, get the count of the word and add it to
        //       the total count
hl    }
    fclose(reader);
    printf("%d\n", count);
    return 0;
}

\{{\code-block}}

### Count the Word in the Line

Now, we need a function to count the number of times the word shows up in the
line.
We can then add it to the {count}.
For now, we're going to create a function called {count_word_in_line} that takes
in a line and the word we want to count and return the number of times the word
shows up in the line.

\{{code-block c}}

#include {{lt}}stdio.h{{gt}}

int main(int argc, char ** argv) {
    if (3 {{gt}} argc) {
        fprintf(stderr, "./word_counter file_name word_to_find\n");
        return -1;
    }
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
    unsigned int count = 0;
    FILE * reader = fopen(file_name, "r");
    const int line_sz = 4096;           // There are better ways to do this
    char line[line_sz];                 // but we need features we haven't
                                        // gone over yet.
    while (fgets(line, line_sz, reader)) {
hl        count += count_word_in_line(line, word);
    }
    fclose(reader);
    printf("%d\n", count);
    return 0;
}

\{{\code-block}}

Now, we just have to write {count_word_in_line}.

## Getting the Word Count for a Line

Since {count_word_in_line} is going to be useful later in other programs, we
might as well put it in another file so we can reuse it.
Because we're going to put it in another file, we're going to have to also make
another header file.
I feel like we're going to need to do other string operations for our programs,
so we're going to create the files {str-operations.h} and {str-operations.c}.
You can make these files through <a href="#creating-a-file"
onclick="highlight_link(this, '#EEAAEE')">the same process in which you created
the {word-counter.c} file</a>.

For {count_word_in_line}, we're going to need the line, the word we want to
find, and we're going to return an {int} to get the proper count, which means
{count_word_in_line} has the syntax:

\{{code-block c no-line-numbers}}

int count_word_in_line(const char * line, const char * word);

\{{\code-block}}

We add the {const}s because we'll modify neither the {word} nor the {line}.
Since we just need {count_word_in_line}, {str-operations.h} will look like

\{{code-block c}}

hlint count_word_in_line(const char * line, const char * word);

\{{\code-block}}

Furthermore, we're going to want to {#include {{zs}}"str-operations.h"} in
{word-counter.c} so that we can use {count_word{{zs}}_in_line} in
{word-counter.c}.

\{{code-block c}}

hl#include "str-operations.h"
#include {{lt}}stdio.h{{gt}}

int main(int argc, char ** argv) {
    if (3 {{gt}} argc) {
        fprintf(stderr, "./word_counter file_name word_to_find\n");
        return -1;
    }
    char * program_name = argv[0];
    char * file_name = argv[1];
    char * word = argv[2];
    unsigned int count = 0;
    FILE * reader = fopen(file_name, "r");
    const int line_sz = 4096;           // There are better ways to do this
    char line[line_sz];                 // but we need features we haven't
                                        // gone over yet.
    while (fgets(line, line_sz, reader)) {
        count += count_word_in_line(line, word);
    }
    fclose(reader);
    printf("%d\n", count);
    return 0;
}

\{{\code-block}}

Now, we're actually done with {word-counter.c}, so the rest of this article will
be working on {str-operations.c} and {str-operations.h}.

## {str-operations.c}

Now, we're going to come up with the algorithm to count the word in the line.

\{{ol}}

Initialize an empty {int} that will serve as the {count}.

While we haven't reached the end of the line:
\{{ol}}

find the next word,

convert it to uppercase to account for differences in ASCII uppercase and
lowercase,

and add one to the count if it matches the input word.

\{{\ol}}

return the {count}.

\{{\ol}}

### {check_if_strings_differ}

We have already written {check_if_{{zs}}strings_differ}, so we can just put it
into {str-operations.c} near the top.

\{{code-block c}}

hlint check_if_strings_differ(char * str1, char * str2) {
hl    int i = 0;
hl    while (str1[i] && str2[i] && (str1[i] == str2[i])) {
hl        i += 1;
hl    }
hl    return str1[i] != str2[i];
hl}

\{{\code-block}}

### Converting Text to Uppercase

We also want to be able to convert things to the same case so that we match
"the" and "The", so we'll need to write a function for it.
Since we'll be converting from lowercase to uppercase, we'll call this function
{to_upper}.
Since we haven't covered dynamic memory allocation, we'll have to convert the
characters to uppercase in place, meaning we're going to modify the original
string and we won't need to {return} anything.
Our function declaration will look like

\{{code-block c}}

hlvoid to_upper(char * string);
int count_word_in_line(const char * line, const char * word);

\{{\code-block}}

We're going to want to go through all the characters in the string, so we're
going to need a {while} loop like so:

\{{code-block c no-line-numbers}}

void to_upper(char * string) {
    int i = 0;
    while (string[i]) {
        // TODO: convert string[i] to uppercase if necessary
        i++;
    }
}

\{{\code-block}}

The code above will loop through each character of the string until it reaches
the end of the string since {'\0'} is {0} and {0} is false in {C}.
We can access the current character by using {string[i]}.
Lowercase ASCII characters are between {'a'} and {'z'} inclusive, so we just
need to check if the current character is greater than or equal to {'a'} and
less than or equal to {'z'}.

\{{code-block c no-line-numbers}}

void to_upper(char * string) {
    int i = 0;
    while (string[i]) {
hl        if ('a' {{lt}}= string[i] && 'z' {{gt}}= string[i]) {
            // TODO: convert string[i] to uppercase
hl        }
        i++;
    }
}

\{{\code-block}}

We'll want to subtact {32} from the character if it is a lowercase ASCII
character since the numerical value of a lowercase letter is {32} more than it's
corresponding uppercase letter.
We haven't covered bitwise operators, which would also work, but we're going to
continue with this method.

\{{code-block c no-line-numbers}}

void to_upper(char * string) {
    int i = 0;
    while (string[i]) {
        if ('a' {{lt}}= string[i] && 'z' {{gt}}= string[i]) {
hl            string[i] -= 32;
        }
        i++;
    }
}

\{{\code-block}}

Now, we just need to add it to {str-operations.c}.
Since it's declared in {str-operations.h}, we can just {#include} it and we
won't need to worry about where it is in the file.

\{{code-block c}}

hl#include "str-operations.h"

hlvoid to_upper(char * string) {
hl    int i = 0;
hl    while (string[i]) {
hl        if ('a' {{lt}}= string[i] && 'z' {{gt}}= string[i]) {
hl            string[i] -= 32;
hl        }
hl        i++;
hl    }
hl}

int check_if_strings_differ(char * str1, char * str2) {
    int i = 0;
    while (str1[i] && str2[i] && (str1[i] == str2[i])) {
        i += 1;
    }
    return str1[i] != str2[i];
}

\{{\code-block}}

### Starting to Write {count_word_in_line}

We'll need to take care of the function input and output first, which we've done
below.

\{{code-block c}}

#include "str-operations.h"

void to_upper(char * string) {
    int i = 0;
    while (string[i]) {
        if ('a' {{lt}}= string[i] && 'z' {{gt}}= string[i]) {
            string[i] -= 32;
        }
        i++;
    }
}

int check_if_strings_differ(char * str1, char * str2) {
    int i = 0;
    while (str1[i] && str2[i] && (str1[i] == str2[i])) {
        i += 1;
    }
    return str1[i] != str2[i];
}

hlint count_word_in_line(const char * line, const char * word) {
hl    int count = 0;
hl    // TODO: For each word in line:
hl        //   1. Convert the word to uppercase
hl        //   2. Check if the current word matches the input word
hl        //   3. Add one to the count if it matches the input word
hl    return count;
hl}

\{{\code-block}}



\{{code-block c}}

int count_word_in_line(const char * line, const char * word) {
    const int buff_sz = 1024;
    char word_buffer[buff_sz];
    int count = 0;
    int begin = 0;
    int word_length = 1;
    while (word_length) {
        begin += find_next_word_begin(line + begin);
        // Remember that begin changed in the last line.
        word_length = find_next_word_end(line + begin);
        if (word_length {{gt}}= buff_sz) {
            word_length = buff_sz - 1;
        }
        strncpy(word_buffer, line + begin, word_length);
        to_upper(word_buffer);
        word_buffer[word_length] = '\0';
        if (!check_if_strings_differ(word, word_buffer)) {
            count += 1;
        }
        begin += word_length + 1;
    }
    return count;
}

\{{\code-block}}
