<!doctype html>
<html lang="en-US">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="">
		<link rel="icon" type="image/x-icon" href="https://tuacm.com/resources/favicon.png">
		<link rel="stylesheet" href="https://tuacm.com/css/nanobs.css">
		<link rel="stylesheet" href="https://tuacm.com/css/general.css">
		<link rel="stylesheet" href="https://tuacm.com/css/article.css">
		<link rel="stylesheet" href="https://tuacm.com/css/code-style/trac+dark.css">
		<link rel="stylesheet" href="https://tuacm.com/css/aside.css">
		<link rel="stylesheet" href="https://tuacm.com/css/code-block.css">
		<style>
			table {
				margin-bottom: 1em;
			}
			.c-type-list {
				overflow: auto;
				margin: 0 auto;
				margin-bottom: 1em;
			}
			.c-type-list th {
				text-align: center;
			}
			.c-type-list th, .c-type-list td {
				padding: 0 1ch 0 1ch;
			}
			.c-type-list tr {
				text-align: right;
			}
			.c-type-head {
				text-align: center;
				border-bottom: 1px solid #000000;
			}
		</style>
		<link rel="stylesheet" href="https://tuacm.com/css/author-description.css">
		<title>Fundamental Types in C</title>
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146716017-1"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());
			gtag('config', 'UA-146716017-1');
		</script>
	</head>
	<body id="body-handle">
		<div id="webpage-header" class="text-center py-5 mb-5 bg-yellow" style="background: black;">
			<img src="https://tuacm.com/resources/tuacm-logo.svg?sanitize=True" alt="TU ACM logo." style="width: calc(30% + 150px);">
			<div>
				<a href="https://tuacm.com/blog" class="font-weight-bolder" style="color: #DC144C; font-size: calc(1.5em + 1vw);">blog</a>
			</div>
		</div>
		<div>
			<div class="article">
				<div id="article-title"><h1 id="fundamental-types-in-c">Fundamental Types in C</h1></div>
				<div id="meta-description">"I'm very font of you, you must be my type."</div>
				<div id="date-and-tags">Posted 15 January 2020 at 1:26 PM </div>
				<div id="author-box">
					<div id="author-image" style="background: url(https://tuacm.com/authors/joseph-mellor/large.jpg) 50% 50% no-repeat; background-size: auto 50px;"></div>
					<div id="author-name">By Joseph Mellor</div>
				</div>
				<hr style="border: 3px solid black;">
				<p><i>This is the sixth article in the </i>Making Sense of C<i> series.
					In this article, we're going to discuss the types built into the <code>C</code> language.
					We'll focus mainly on the numerical applications of these types and how they
					interact with each other.
				</p>
				<p>I apologize for the <a href="https://en.wikipedia.org/wiki/Type_punning">type
					punning</a> in the tagline above.
					Credit to Jake Doerfler for showing me that pun.
					</i>
				</p>
				<p>So far, we've determined that we're going to give the compiler a file we want it
					to read, we've come up with a few basic rules about the format of the file (e.g.
					ending statements with semicolons), we've come up with a way to tell the
					compiler to ignore our comments within the code, we've established that we can
					do arithmetic, and we've set up a system for declaring variables, but we've only
					specified one type, an <code>int</code>.
					We've also never discussed how we can use floating point types in <code>C</code>, nor what
					we should do when different types interact.
				</p>
				<p>If you haven't read the <a href="https://tuacm.com/blog/memory-hierarchy/">article on managing
					memory</a>, you should read it to understand why we have multiple types to
					represent whole numbers.
					If you want to know more about how your computer represents integers, read the
					<a href="https://tuacm.com/blog/integer-representations-binary/">article on integer representation</a>.
					Lastly, if you want to know more about how your computer represents floating
					point numbers, read the <a href="https://tuacm.com/blog/floating-point/">article on
					representing floating point numbers</a>.
				</p>
				<h2 id="topics-covered">Topics Covered</h2>
				<ul>
					<li><b>Integral Types</b>
					</li>
					<li><b>Signed vs Unsigned Types</b>
					</li>
					<li><b>Floating Point Types</b>
					</li>
					<li><b>Interactions Between Different Types</b>
					</li>
				</ul>
				<h2 id="integral-types">Integral Types</h2>
				<p>So, we need to have a few different integral types because we want people to <a
					href="https://tuacm.com/blog/memory-hierarchy/">use memory effectively</a>.
					If they want big numbers, we can let them use big numbers.
					If they don't need to use big numbers, we can let them use numbers that take up
					less memory to help them write efficient programs.
					If they're using computers with little memory (such as embedded computers), then
					they'll be able to save space.
					We should also let them declare signed and unsigned versions of the types since
					sometimes they won't need negative numbers, and doing so will allow them to use
					twice as many positive numbers.
				</p>
				<p>On most non-embedded computers, you'll find the following setup:
				</p>
				<table class="c-type-list">
					<tr>
						<th colspan="4" class="c-type-head">Integral Types in C</th>
					</tr>
					<tr class="c-type-head">
						<th>Type&nbsp;&nbsp;</th>
						<th>Size<br>in<br>Bits</th>
						<th>Range of<br>Signed</th>
						<th>Maximum<br><code>unsigned</code><br>Value</th>
					</tr>
					<tr style="background: #E0E0E0;">
						<td style="text-align: left;"><code>char</code></td>
						<td>8</td>
						<td><code>-128</code> to <code>127</code></td>
						<td><code>255</code></td>
					</tr>
					<tr>
						<td style="text-align: left;"><code>short</code></td>
						<td>16</td>
						<td><code>-32 768</code> to <code>32 767</code></td>
						<td><code>65 536</code></td>
					</tr>
					<tr style="background: #E0E0E0;">
						<td style="text-align: left;"><code>int</code></td>
						<td>32</td>
						<td><code>-2 147 483 648</code> to <code>2 147 483 647</code></td>
						<td><code>4 294 967 295</code></td>
					</tr>
					<tr style="border-bottom: 1px solid #000000;">
						<td style="text-align: left;"><code>long long</code></td>
						<td>64</td>
						<td><code>-9 223 372 036 854 775 808</code> to<br><code>9 223 372 036 854 775 807</code></td>
						<td><code>18 446 744 073 709 551 615</code></td>
					</tr>
				</table>
				<p>I'm just going to apologize if you're reading on a phone, as I don't have a good
					way to display the table without breaking apart the numbers in an unnatural way.
					Basically, an <code>unsigned char</code> can represent numbers up to 255, an <code>unsigned
					short</code> can represent numbers up to 64&nbsp;000, an <code>unsigned int</code> can represent
					numbers up to four billion, and an <code>unsigned long long</code> can represent numbers up
					to eighteen billion billion.
					Signed types can represent numbers half as large as their corresponding unsigned
					types.
				</p>
				<h3 id="declaring-signed-and-unsigned-variables">Declaring Signed and Unsigned Variables</h3>
				<p>If you declare a variable with just the type, it will be signed.
					If you declare a variable with <code>unsigned</code> in front of the type, it will be
					unsigned.
				</p>
<div class="code-block"><pre><span></span><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>              <span class="c1">// a is a signed int that can go from -2 147 483 648 to</span>
                    <span class="c1">// 2 147 483 647</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>     <span class="c1">// b is an unsigned int that can go from 0 to 4 294 967 295</span>
</pre></div>
				
				<p>You can also put <code>signed</code> in front of a type to make it signed, but it doesn't
					add any information since integral types are signed by default.
					Also, <code>short</code> and <code>long long</code> are technically <code>short int</code> and <code>long long int</code>,
					but adding the <code>int</code> is unnecessary.
				</p>
				<h3 id="why-do-some-types-have-weird-names">Why do Some Types Have Weird Names?</h3>
				<p>An <code>int</code> represents numbers in the normal range for most calculations and a
					<code>short</code> represents a smaller range, so both <code>int</code> and <code>short</code> make sense, but
					why is the eight bit type a <code>char</code> and why is the 64 bit type a <code>long long</code>?
					What happened to the <code>long</code> type?
				</p>
				<h4 id="the-char-type">The <code>char</code> Type</h4>
				<p>Considering that you can't even store the result of small calculations like
					<code>12 * 12</code> in eight bits, why even have an eight bit type?
					While you can still do arithmetic with <code>char</code>s, they are mostly used to
					represent characters in text.
					For example, the letter 'A' has the value of <code>65</code>, the letter 'B' has the value
					of <code>66</code>, etc.
					Since ASCII only uses 128 characters, there's no reason to use more than a byte
					of memory for a character.
				</p>
				<h4 id="the-long-long-type">The <code>long long</code> Type</h4>
				<p><code>C</code> actually has a <code>long</code> type, but I didn't mention it because the length in
					bits of the <code>int</code> and <code>long</code> types vary from computer to computer.
					In the case of the lengths of integer types, the <code>C</code> standard only specifies a
					minimum length.
					For example, an <code>int</code> must be at least <code>16</code> bits long and a <code>long</code> must be at
					least <code>32</code> bits long.
					On some computers, an <code>int</code> is only <code>16</code> bits instead of <code>32</code> bits, which means
					you could see bugs if your program relies on an <code>int</code> being <code>32</code> bits.
					It's not as much of a problem as you would expect since most compilers use the
					standard <code>32</code> bits for an <code>int</code> and those that don't will make it explicit that
					they use <code>16</code> bits.
					A <code>long long</code>, however, is guaranteed to be at least <code>64</code> bits long, but most
					compilers don't go beyond <code>64</code> bits, so a <code>long long</code> is effectively guaranteed
					to be <code>64</code> bits.
				</p>
				<h2 id="floating-point-types">Floating Point Types</h2>
				<p>Now that we've set up the integral types, let's move onto the floating point
					types.
					Because of how <a href="https://tuacm.com/blog/floating-point/">floating point numbers
					work</a>, it won't make sense to have a floating point number be one or two
					bytes.
					Since we do powers of two, let's make floating point types with four bytes and
					eight bytes.
				</p>
				<p>In <code>C</code>, we have two standard floating point types:
				</p>
				<table class="c-type-list">
					<tr>
						<th colspan="4" class="c-type-head">Floating Point Types in C</th>
					</tr>
					<tr class="c-type-head">
						<th>Type</th>
						<th>Size in Bits</th>
						<th>Range</th>
						<th>Precision<br>in Digits</th>
					</tr>
					<tr style="background: #E0E0E0">
						<td><code>float</code></td>
						<td>32</td>
						<td><code>&pm;3.40e38</code></td>
						<td>~7</td>
					</tr>
					<tr style="border-bottom: 1px solid #000000;">
						<td><code>double</code></td>
						<td>64</td>
						<td><code>&pm;1.79e308</code></td>
						<td>~16</td>
					</tr>
				</table>
				<p>Both floating point types represent numbers in signed scientific notation, which
					is why the ranges for both are in scientific notation.
					A <code>float</code> can represent numbers up to a hundred billion billion billion billion
					and a <code>double</code> can represent pretty much any number you'll encounter in
					programming.
					<b style="color: #FF0000">Both however, cannot represent large numbers exactly,
					so you shouldn't use either if you're doing anything that requires an exact
					amount, like counting money or doing anything with number theory</b>.
					You should use <code>float</code>s and <code>double</code>s when you don't need to be exact (physics
					and graphics calculations in video games, sciences where you use scientific
					notation, etc.).
					<a href="https://www.youtube.com/watch?v=PZRI1IfStY0">Tom Scott did a video on
					floating point numbers</a> that you should watch for just some general warnings
					and use cases for floating point numbers.
				</p>
				<p>Unlike with the integral types, these floating point types are standardized,
					meaning you'll never see a 64 bit <code>float</code> or a 32 bit <code>double</code>.
				</p>
				<p>Since we're dealing with such big numbers, we should be able to initialize
					numbers with scientific notation, so let's add that to the language.
				</p>
				<p>We'll use the syntax <code>[decimal]e[exponent]</code> for scientific notation literals,
					like so:
				</p>
<div class="code-block"><pre><span></span><span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">7.03e5</span><span class="p">;</span>      <span class="c1">// a now contains 703 000, as the &#39;e&#39; can be read</span>
                        <span class="c1">// as &quot;times ten to the&quot;</span>
<span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</pre></div>
				
				<h2 id="how-do-numbers-from-different-types-interact-with-each-other">How do Numbers from Different Types Interact with Each Other?</h2>
				<p>We've established how arithmetic is going to work for numbers of the same type,
					but what happens if we try to perform arithmetic with numbers of different
					types?
				</p>
				<p><b>In general, we should avoid making different types interact with each
					other</b>.
					Like different tools in a toolbox, each type has specific scenarios when you
					should use it.
					Just as it doesn't make sense to unscrew a screw with a hammer, it doesn't make
					sense to use an <code>int</code> to represent a probability.
					If multiple types are interacting, it's likely that at least one of them is
					being used for the wrong job.
				</p>
				<p>To be clear, there are specific use cases where you need to use multiple types,
					such as converting money (which should be stored in an integral type) between
					countries using an exchange rate (which should be stored in a floating-point
					type).
				</p>
				<p>So that you have no surprises when you do have to have different types interact,
					I will discuss the type interactions in the rest of the section.
				</p>
				<p>To figure out what to do, we should try to follow the <a
					href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle
					of least surprise</a>, which essentially states that anything that a user (in
					our case, a <code>C</code> programmer) can interact with should work exactly as the user
					would expect.
					As a simple example, the plus sign should do some kind of addition, but never
					subtraction.
				</p>
				<h3 id="what-happens-if-we-add-a-short-to-a-long-long">What Happens if We Add a <code>short</code> to a <code>long long</code>?</h3>
				<p>Just because we represent a number with fewer bytes doesn't mean it should stop
					acting like a number.
					The sum of <code>32</code> and <code>7000000000224</code> should be <code>7000000000256</code> if possible, but
					the only way to have that happen is to temporarily convert the <code>short</code> into a
					<code>long long</code>.
					Since temporarily converting a <code>short</code> to a <code>long long</code> is trivial, let's just
					temporarily convert the <code>short</code> into a <code>long long</code>, then do the addition.
				</p>
				<p>When you do arithmetic with two numbers of different types, the number of the
					smaller type will be converted to the larger type, then the two numbers are
					added just as if they were of the same type.
					For example:
				</p>
<div class="code-block"><pre><span></span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1000000000000</span><span class="p">;</span>        <span class="c1">// one trillion</span>
<span class="kt">short</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>                <span class="c1">// c now contains one trillion three</span>
                                    <span class="c1">// thousand</span>
</pre></div>
				
				<p>In fact, <b>when you perform any arithmetic operation with numbers from two
					different types, the smaller type will get converted to the larger type before
					the operation gets applied</b>.
				</p>
				<h3 id="what-happens-if-we-add-a-float-to-a-double">What Happens if We Add a <code>float</code> to a <code>double</code>?</h3>
				<p>Just like adding a <code>short</code> to a <code>long long</code>, the smaller type (<code>float</code>) will be
					converted to the larger type (<code>double</code>), then added together like two doubles.
				</p>
				<h3 id="what-happens-if-we-add-an-int-to-a-float">What Happens if We Add an <code>int</code> to a <code>float</code>?</h3>
				<p>Just like adding a <code>short</code> to a <code>long long</code>, the smaller type (the non-floating
					point type) will be converted into the larger type (the floating point type),
					then the two types will be added together like two floats.
				</p>
<div class="code-block"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">45.6</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// a becomes 40.0 and is added to 45.6 to get 85.6, which is</span>
                    <span class="c1">// then stored in c</span>
</pre></div>
				
				<h3 id="what-happens-if-we-try-to-store-a-smaller-type-in-a-larger-type">What Happens if We Try to Store a Smaller Type in a Larger Type?</h3>
				<p>Since the larger type can completely represent the shorter type, it gets stored
					without a problem.
					This applies to all types, but there can be a loss of precision in converting
					from an integral type to a floating point type.
				</p>
				<h4 id="loss-of-precision">Loss of Precision</h4>
				<p>Because we floating point numbers trade precision for range, there can be a loss
					of precision in converting from an integral type to a floating point type, so
					you will lose some precision of the number if the number is larger than
					<i>2<sup>24</sup></i> if you want to store it in a <code>float</code> or
					<i>2<sup>53</sup></i> if you want to store it in a <code>double</code>.
				</p>
<div class="code-block"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2147483611</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">45.6</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>        <span class="c1">// c does not contain 2147483656.6, but 2.147483648e9</span>
                        <span class="c1">// because a became 2.147483648e9 in the addition (a is</span>
                        <span class="c1">// still 2147483611, it&#39;s just being temporarily</span>
                        <span class="c1">// converted to a floating point number for the</span>
                        <span class="c1">// addition) and b was too insignificant to change it,</span>
                        <span class="c1">// just like 2e100 + 1 is still 2e100</span>
</pre></div>
				
				<p>In the last example, although it looks like <code>2.147483648e9</code> has 10 sigfigs, it
					only has 8 accurate sigfigs.
					But if it only has 8 sigfigs, then why wasn't it <code>2.1474836e9</code>?
					Why did it include the <code>48</code> at the end?
				</p>
				<p>Remember that the computer works in binary, not base ten.
					When I said that <code>a</code> became <code>2.147483648e9</code> in the addition, I was giving you
					the number in a correct, but misleading format.
					To the computer, <code>a</code> was actually first converted to <code>1.111 1111 1111 1111 1111
					1111 1011 011e0001&nbsp;1110</code>, which corresponds to <i>2<sup>31</sup> -
					37</i>.
					Since the computer can only represent the first twenty four digits as a <code>float</code>,
					it will round to the nearest representable number it can, which is <code>1.000 0000
					0000 0000 0000 0000e0001&nbsp;1111</code> or <i>2<sup>31</sup></i>.
					Notice that the computer version has 24 significant bits with all the zeros.
					In other words, it has the proper number of significant figures <i>in base
					two</i>, not in base ten.
				</p>
				<p>If <code>b</code> were instead a <code>double</code>, then we would convert <code>a</code> to a <code>double</code>, which
					actually has the required precision to represent <code>a</code>, meaning you would get the
					correct answer of <code>2147483656.599998</code>, where the remaining <code>0.000002</code> comes from
					the fact that <code>0.6</code> can't be represented in a finite number of bits, just as we
					have to represent <code>2/3</code> as <code>0.666...6667</code> in a finite number of digits.
					For more details, check out <a
					href="https://www.youtube.com/watch?v=PZRI1IfStY0">Tom Scott's video on floating
					point numbers</a>, which I referred to earlier.
				</p>
				<h3 id="what-happens-if-we-try-to-store-a-long-long-in-a-short">What Happens if We Try to Store a <code>long long</code> in a <code>short</code>?</h3>
				<p>First, if you try to directly set a type with a value too large for it to
					handle, the compiler will print out some warning when you try to compile your
					program but it won't throw an error.
					If you set <code>a</code> equal to some expression it can't figure out at compile time,
					then it might not print a warning, so you should be on your guard.
				</p>
<div class="code-block"><pre><span></span><span class="hll"><span class="kt">short</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>       <span class="c1">// WARNING: overflow in implicit constant conversion</span>
</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>                  <span class="c1">// The compiler might not print a warning for this</span>
                            <span class="c1">// line, even though it will overflow.</span>
</pre></div>
				
				<p>In general, the compiler will chop off any digits it can't fit into the assigned
					type.
					In the example above, <code>1000000000</code> in base ten is <code>0011 1011 1001 1010 1100 1010
					0000 0000</code> in binary, but since a short can only hold <code>16</code> bits, it will only
					take the rightmost sixteen bits and treat the rest as overflow, meaning that you
					would be setting <code>a</code> to <code><s>0011 1011 1001 1010</s> 1100 1010 0000
					0000</code>&rArr;<code>1100 1010 0000 0000</code>, which is <code>-13824</code>.
					You could have replaced the highlighted line with <code>short a = -13824;</code> and the
					results of the program would be exactly the same.
				</p>
				<div class="aside" >
					<h5>Undefined Integer Behavior</h5>
					<hr>
					<p>Because <code>C</code> was made way back when people were building computers using
						nonstandard methods like one's compliment and sign-magnitude representation for
						integers and computers with different sizes for <code>int</code> and short, <code>C</code> wanted to
						accomodate all the different behaviors of computers, so some things are left
						undefined in the <code>C</code> standard and it's up to the people building the hardware
						what to do in these cases.
					</p>
					<p>For example, nothing in the <code>C</code> standard states that you have to use two's
						compliment to represent integral types, which means overflow for signed integral
						types has to be undefined.
						All three representations of binary agree that <code>0111 1111 1111 1111 1111 1111
						1111 1111</code> represents the largest positive signed 32 bit number.
						Adding one to that number, however, leads to three different results.
						<code>1000 0000 0000 0000 0000 0000 0000 0000</code> represents <code>-2 147 483 648</code> in two's
						compliment, <code>-0</code> in sign-magnitude, and <code>-2 147 483 647</code> in one's compliment.
					</p>
					<p>Also, the <code>C</code> standard actually specifies that both a <code>short</code> and an <code>int</code> only
						have to represent the numbers from <code>-32 767</code> to <code>32 767</code> because one's
						compliment and sign-magnitude can't represent <code>-32 768</code> in sixteen bits and
						some computers represent <code>int</code>s with sixteen bits instead of thirty two bits.
						Once again, most computers follow the layout I specified above, with the notable
						exception of embedded computers.
					</p>
					<p>The trick to avoiding this whole mess is just to avoid undefined behavior in the
						first place.
						Don't let numbers overflow and don't rely on needing to use <code>-2 147 483 648</code>.
					</p>
				</div>
				<h3 id="what-happens-if-we-try-to-store-an-int-in-a-float">What Happens if We Try to Store an <code>int</code> in a <code>float</code>?</h3>
				<p>If the value of the <code>int</code> is less than <i>2<sup>24</sup></i>, then it can be
					stored in the <code>float</code> completely, otherwise, it can be rounded to the nearest
					float that can be represented.
					You already saw an example above in the <a href="#loss-of-precision">Loss of
					Precision</a> section.
				</p>
				<h3 id="what-happens-if-we-try-to-store-a-double-in-a-float">What Happens if We Try to Store a <code>double</code> in a <code>float</code>?</h3>
				<p>Simply put, if the value of the <code>double</code> can fit into the <code>float</code>, then it gets
					stored without a problem.
					If the <code>double</code> has more precision than the <code>float</code> can store, the extra
					precision is thrown away.
					If the magnitude of the value of the <code>double</code> is greater than a <code>float</code> can
					store, it just stores <code>&pm;inf</code> (which represents infinity) in the <code>float</code>.
				</p>
<div class="code-block"><pre><span></span><span class="kt">double</span> <span class="n">can_fit_in_float</span> <span class="o">=</span> <span class="mf">1.125</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">example</span> <span class="o">=</span> <span class="n">can_fit_in_float</span><span class="p">;</span>   <span class="c1">// example is now 1.125</span>

<span class="kt">double</span> <span class="n">too_precise</span> <span class="o">=</span> <span class="mf">1.0000000009e7</span><span class="p">;</span>
<span class="n">example</span> <span class="o">=</span> <span class="n">too_precise</span><span class="p">;</span>              <span class="c1">// example is now 1e7, where the</span>
                                    <span class="c1">// 0.0000000009e7 is dropped</span>

<span class="kt">double</span> <span class="n">too_large</span> <span class="o">=</span> <span class="mf">1e100</span><span class="p">;</span>           <span class="c1">// too_large is now the power of two nearest</span>
                                    <span class="c1">// to 1e100 because of how double precision</span>
                                    <span class="c1">// works</span>

<span class="n">example</span> <span class="o">=</span> <span class="n">too_large</span><span class="p">;</span>                <span class="c1">// example is now inf, which represents</span>
                                    <span class="c1">// infinity, because 1e100 is too large for</span>
                                    <span class="c1">// a float to represent</span>

<span class="kt">double</span> <span class="n">set_to_infinity</span> <span class="o">=</span> <span class="n">example</span><span class="p">;</span>   <span class="c1">// set_to_infinity is now inf because</span>
                                    <span class="c1">// example is inf</span>

<span class="n">set_to_infinity</span> <span class="o">=</span> <span class="n">too_large</span><span class="p">;</span>        <span class="c1">// set_to_infinity is now the power of two</span>
                                    <span class="c1">// nearest to 1e100 since too_large can fit</span>
                                    <span class="c1">// into set_to_infinity</span>
</pre></div>
				
				<h3 id="what-happens-if-we-try-to-store-a-double-in-an-int">What Happens if We Try to Store a <code>double</code> in an <code>int</code>?</h3>
				<p>If the value of the <code>double</code> can fit into an <code>int</code>, then the <code>double</code> gets
					converted into an <code>int</code>, which means it just removes any fractional part.
				</p>
<div class="code-block"><pre><span></span><span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>          <span class="c1">// b is now 1</span>
<span class="n">a</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>            <span class="c1">// a is now -1.5</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>              <span class="c1">// b is now -1, since the fractional part gets removed</span>
</pre></div>
				
				<p>If the value of the <code>double</code> can't fit into an <code>int</code>, then you'll probably get
					some garbage value, so don't try to store a <code>double</code> in an <code>int</code> if you know
					it won't fit.
				</p>
				<h2 id="type-casting">Type Casting</h2>
				<p>To force a conversion from a type to another type in an expression (you cannot
					change the type of any variable), you can use a <b>type cast</b>, which consists
					of putting the resulting type in front of the variable or expression.
					For example, if you want to exchange 100 USD for some yen, you would multiply
					10000 cents (since the cent is the smallest unit of US currency) by the cents to
					yen conversion rate.
					Both cents and yen are discrete quantities, so it wouldn't make sense for your
					resulting money to be floating point numbers.
					On the other hand, the cents to yen conversion rate is a floating point number,
					meaning that to convert from cents to yen requires multiplying an integral
					number by a floating point number, which results in a <b>floating point</b>
					number, which you have to convert back into an integral number, either
					implicitly by doing anything involving multiple types as specified above or
					explicitly by using a <b>type cast</b>.
				</p>
				<p>Since the only thing the compiler needs to know to convert one type to another
					is what you're converting and the resultant type, it uses the syntax
					<code>(new_type)variable</code>.
					In our example:
				</p>
<div class="code-block"><pre><span></span><span class="c1">// cents_to_yen has been intialized as a double</span>
<span class="c1">// cents has been initialized as a long long</span>

<span class="c1">// Implicit conversion by storing</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cents</span> <span class="o">*</span> <span class="n">cents_to_yen</span><span class="p">;</span>

<span class="c1">// Explicit conversion using type casting</span>
<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">cents</span> <span class="o">*</span> <span class="n">cents_to_yen</span><span class="p">)</span>
</pre></div>
				
				<p>Type casts will show up from time to time, so just know that you can convert
					types to other types.
				</p>
				<h2 id="summary">Summary</h2>
				<p>Up to this point, we've established that we're going to give our compiler a file
					with a series of statements, but we've only used the plain <code>int</code> type.
					In this article, we explained what <code>int</code>s are doing under the hood and we
					introduced several new types that function like <code>int</code>s.
					We also introduced the concept of signed and unsigned integers.
					Our file should now look like
				</p>
<div class="code-block"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1000000000000</span><span class="p">;</span>
<span class="n">b</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span>                             <span class="c1">// Multiplying an unsigned long long and an</span>
                                    <span class="c1">// int works exactly as expected.</span>
                                    <span class="c1">// b is now seven trillion</span>

<span class="n">other</span> <span class="n">statement</span><span class="p">;</span>                    <span class="c1">// We still can&#39;t do anything more than</span>
                                    <span class="c1">// arithmetic.</span>

<span class="kt">short</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>                   <span class="c1">// Since 32 * 7 is less than the maximum</span>
                                    <span class="c1">// value for a short, we&#39;re good even though</span>
                                    <span class="c1">// a is an int.</span>
                                    <span class="c1">// c is now 224.</span>

<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">1e7</span><span class="p">;</span>                 <span class="c1">// 1e7 is 10000000.</span>
                                    <span class="c1">// d now contains 70000000000000000000.</span>

<span class="n">b</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>                             <span class="c1">// Adding a short to an unsigned long long</span>
                                    <span class="c1">// works as expected.</span>
                                    <span class="c1">// b is now 7000000000224</span>
<span class="n">d</span> <span class="o">/=</span> <span class="n">b</span><span class="p">;</span>                             <span class="c1">// d now contains 9999999.999680</span>

<span class="n">b</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>                           <span class="c1">// b is now 3500000000112</span>
</pre></div>
				
				<h2 id="whats-next">What's Next</h2>
				<p>Remember that our goal for now is to count the number of times a word shows up
					in some particular text.
					We've set up counting, so now our next move should be to handle and manipulate
					text, which will be the topic of the next article.
					Since text manipulation will be too complicated to fully explain in a single
					article, we will first come up with an abstract, kind of hazy system for
					representing text in the next article, then we will try to come up with features
					in the language that will allow us to implement the system we came up with.
					We might also need to modify our system when future constraints come up.
				</p>
				<p>See you in the next article: <a href="../strings/index.html">Representing Text
					in C</a>.
				</p>
			</div>
			<div class="article">
				<div id="author-description-local">
					<img src="https://tuacm.com/authors/joseph-mellor/large.jpg" id="author-description-image" alt="A picture of Joseph Mellor, the author.">
					<div id="author-description-text">
						<p>Joseph Mellor is a Junior at TU majoring in Physics, Computer Science, and
							Math.
							He is also the chief editor of the website and the author of the tumd markdown
							compiler.
							If you want to see more of his work, check out his <a
							href="https://github.com/TheLandfill">github repository</a>.
							<br>
							Credit to Allison Pennybaker for the picture.
						</p>
					</div>
				</div>
			</div>
			<nav id="sidenav">
				<a href="#fundamental-types-in-c" style="padding-left:12px;">Fundamental Types in C</a>
				<a href="#topics-covered" style="padding-left:24px;">Topics Covered</a>
				<a href="#integral-types" style="padding-left:24px;">Integral Types</a>
				<a href="#declaring-signed-and-unsigned-variables" style="padding-left:36px;">Declaring Signed and Unsigned Variables</a>
				<a href="#why-do-some-types-have-weird-names" style="padding-left:36px;">Why do Some Types Have Weird Names?</a>
				<a href="#the-char-type" style="padding-left:48px;">The <code>char</code> Type</a>
				<a href="#the-long-long-type" style="padding-left:48px;">The <code>long long</code> Type</a>
				<a href="#floating-point-types" style="padding-left:24px;">Floating Point Types</a>
				<a href="#how-do-numbers-from-different-types-interact-with-each-other" style="padding-left:24px;">How do Numbers from Different Types Interact with Each Other?</a>
				<a href="#what-happens-if-we-add-a-short-to-a-long-long" style="padding-left:36px;">What Happens if We Add a <code>short</code> to a <code>long long</code>?</a>
				<a href="#what-happens-if-we-add-a-float-to-a-double" style="padding-left:36px;">What Happens if We Add a <code>float</code> to a <code>double</code>?</a>
				<a href="#what-happens-if-we-add-an-int-to-a-float" style="padding-left:36px;">What Happens if We Add an <code>int</code> to a <code>float</code>?</a>
				<a href="#what-happens-if-we-try-to-store-a-smaller-type-in-a-larger-type" style="padding-left:36px;">What Happens if We Try to Store a Smaller Type in a Larger Type?</a>
				<a href="#loss-of-precision" style="padding-left:48px;">Loss of Precision</a>
				<a href="#what-happens-if-we-try-to-store-a-long-long-in-a-short" style="padding-left:36px;">What Happens if We Try to Store a <code>long long</code> in a <code>short</code>?</a>
				<a href="#what-happens-if-we-try-to-store-an-int-in-a-float" style="padding-left:36px;">What Happens if We Try to Store an <code>int</code> in a <code>float</code>?</a>
				<a href="#what-happens-if-we-try-to-store-a-double-in-a-float" style="padding-left:36px;">What Happens if We Try to Store a <code>double</code> in a <code>float</code>?</a>
				<a href="#what-happens-if-we-try-to-store-a-double-in-an-int" style="padding-left:36px;">What Happens if We Try to Store a <code>double</code> in an <code>int</code>?</a>
				<a href="#type-casting" style="padding-left:24px;">Type Casting</a>
				<a href="#summary" style="padding-left:24px;">Summary</a>
				<a href="#whats-next" style="padding-left:24px;">What's Next</a>
			</nav>
			<div id="sidenav-activator"></div>
		</div>
		<div id="footer" class="mt-5 py-5 text-center px-4">
			<div id="footer-links">
				<a href="#">Blog</a>
				<a href="#">Get Involved</a>
				<a href="http://hacktulsa.com">Hackathon</a>
				<a href="#">GitHub</a>
			</div>
		</div>
		<script src="https://tuacm.com/js/sidenav.js"></script>
	</body>
</html>
